/*
 * This file was auto-generated by speedy-antlr-tool v1.0.0
 *  https://github.com/amykyta3/speedy-antlr-tool
 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstring>

#include "antlr4-runtime.h"
#include "modelicaLexer.h"
#include "modelicaParser.h"
#include "speedy_antlr.h"

#include "sa_modelica_translator.h"

/*
 * Python function prototype:
 *  do_parse(
 *      parser_cls:antlr4.Parser,
 *      stream:antlr4.InputStream,
 *      entry_rule_name:str,
 *      sa_err_listener:SA_ErrorListener
 *  )
 */
PyObject* do_parse(PyObject *self, PyObject *args) {
    PyObject *strdata = NULL;
    PyObject *result = NULL;
    PyObject *token_module = NULL;

    try {
        // Get args
        PyObject *parser_cls = NULL;
        PyObject *stream = NULL;
        const char *entry_rule_name = NULL;
        PyObject *sa_err_listener = NULL;
        if(!PyArg_ParseTuple(args,
            "OOsO:do_parse",
            &parser_cls, &stream, &entry_rule_name, &sa_err_listener
        )) {
            return NULL;
        }

        // Extract input stream's string
        const char *cstrdata;
        Py_ssize_t bufsize;
        strdata = PyObject_GetAttrString(stream, "strdata");
        if(!strdata) throw speedy_antlr::PythonException();
        cstrdata = PyUnicode_AsUTF8AndSize(strdata, &bufsize);
        if(!cstrdata) throw speedy_antlr::PythonException();

        // Create an antlr InputStream object
        antlr4::ANTLRInputStream cpp_stream(cstrdata, bufsize);

        // in case error listener is overridden
        token_module = PyImport_ImportModule("antlr4.Token");
        if(!token_module) throw speedy_antlr::PythonException();
        speedy_antlr::Translator translator(parser_cls, stream);
        speedy_antlr::ErrorTranslatorListener err_listener(&translator, sa_err_listener);

        // Lex
        modelicaLexer lexer(&cpp_stream);
        if(sa_err_listener != Py_None){
            lexer.removeErrorListeners();
            lexer.addErrorListener(&err_listener);
        }
        antlr4::CommonTokenStream token_stream(&lexer);
        token_stream.fill();

        // Parse
        modelicaParser parser(&token_stream);
        if(sa_err_listener != Py_None){
            parser.removeErrorListeners();
            parser.addErrorListener(&err_listener);
        }
        antlr4::tree::ParseTree *parse_tree;
        if(!strcmp(entry_rule_name, "stored_definition")){
            parse_tree = parser.stored_definition();

        } else if(!strcmp(entry_rule_name, "within_statement")){
            parse_tree = parser.within_statement();

        } else if(!strcmp(entry_rule_name, "class_definition")){
            parse_tree = parser.class_definition();

        } else if(!strcmp(entry_rule_name, "class_specifier")){
            parse_tree = parser.class_specifier();

        } else if(!strcmp(entry_rule_name, "class_prefixes")){
            parse_tree = parser.class_prefixes();

        } else if(!strcmp(entry_rule_name, "long_class_specifier")){
            parse_tree = parser.long_class_specifier();

        } else if(!strcmp(entry_rule_name, "short_class_specifier")){
            parse_tree = parser.short_class_specifier();

        } else if(!strcmp(entry_rule_name, "der_class_specifier")){
            parse_tree = parser.der_class_specifier();

        } else if(!strcmp(entry_rule_name, "base_prefix")){
            parse_tree = parser.base_prefix();

        } else if(!strcmp(entry_rule_name, "enum_list")){
            parse_tree = parser.enum_list();

        } else if(!strcmp(entry_rule_name, "enumeration_literal")){
            parse_tree = parser.enumeration_literal();

        } else if(!strcmp(entry_rule_name, "composition")){
            parse_tree = parser.composition();

        } else if(!strcmp(entry_rule_name, "language_specification")){
            parse_tree = parser.language_specification();

        } else if(!strcmp(entry_rule_name, "external_function_call")){
            parse_tree = parser.external_function_call();

        } else if(!strcmp(entry_rule_name, "element_list")){
            parse_tree = parser.element_list();

        } else if(!strcmp(entry_rule_name, "element")){
            parse_tree = parser.element();

        } else if(!strcmp(entry_rule_name, "import_clause")){
            parse_tree = parser.import_clause();

        } else if(!strcmp(entry_rule_name, "import_list")){
            parse_tree = parser.import_list();

        } else if(!strcmp(entry_rule_name, "extends_clause")){
            parse_tree = parser.extends_clause();

        } else if(!strcmp(entry_rule_name, "constraining_clause")){
            parse_tree = parser.constraining_clause();

        } else if(!strcmp(entry_rule_name, "component_clause")){
            parse_tree = parser.component_clause();

        } else if(!strcmp(entry_rule_name, "type_prefix")){
            parse_tree = parser.type_prefix();

        } else if(!strcmp(entry_rule_name, "type_specifier")){
            parse_tree = parser.type_specifier();

        } else if(!strcmp(entry_rule_name, "component_list")){
            parse_tree = parser.component_list();

        } else if(!strcmp(entry_rule_name, "component_declaration")){
            parse_tree = parser.component_declaration();

        } else if(!strcmp(entry_rule_name, "condition_attribute")){
            parse_tree = parser.condition_attribute();

        } else if(!strcmp(entry_rule_name, "declaration")){
            parse_tree = parser.declaration();

        } else if(!strcmp(entry_rule_name, "modification")){
            parse_tree = parser.modification();

        } else if(!strcmp(entry_rule_name, "class_modification")){
            parse_tree = parser.class_modification();

        } else if(!strcmp(entry_rule_name, "argument_list")){
            parse_tree = parser.argument_list();

        } else if(!strcmp(entry_rule_name, "argument")){
            parse_tree = parser.argument();

        } else if(!strcmp(entry_rule_name, "element_modification_or_replaceable")){
            parse_tree = parser.element_modification_or_replaceable();

        } else if(!strcmp(entry_rule_name, "element_modification")){
            parse_tree = parser.element_modification();

        } else if(!strcmp(entry_rule_name, "element_redeclaration")){
            parse_tree = parser.element_redeclaration();

        } else if(!strcmp(entry_rule_name, "element_replaceable")){
            parse_tree = parser.element_replaceable();

        } else if(!strcmp(entry_rule_name, "component_clause1")){
            parse_tree = parser.component_clause1();

        } else if(!strcmp(entry_rule_name, "component_declaration1")){
            parse_tree = parser.component_declaration1();

        } else if(!strcmp(entry_rule_name, "short_class_definition")){
            parse_tree = parser.short_class_definition();

        } else if(!strcmp(entry_rule_name, "equation_section")){
            parse_tree = parser.equation_section();

        } else if(!strcmp(entry_rule_name, "algorithm_section")){
            parse_tree = parser.algorithm_section();

        } else if(!strcmp(entry_rule_name, "equation")){
            parse_tree = parser.equation();

        } else if(!strcmp(entry_rule_name, "statement")){
            parse_tree = parser.statement();

        } else if(!strcmp(entry_rule_name, "if_equation")){
            parse_tree = parser.if_equation();

        } else if(!strcmp(entry_rule_name, "if_statement")){
            parse_tree = parser.if_statement();

        } else if(!strcmp(entry_rule_name, "for_equation")){
            parse_tree = parser.for_equation();

        } else if(!strcmp(entry_rule_name, "for_statement")){
            parse_tree = parser.for_statement();

        } else if(!strcmp(entry_rule_name, "for_indices")){
            parse_tree = parser.for_indices();

        } else if(!strcmp(entry_rule_name, "for_index")){
            parse_tree = parser.for_index();

        } else if(!strcmp(entry_rule_name, "while_statement")){
            parse_tree = parser.while_statement();

        } else if(!strcmp(entry_rule_name, "when_equation")){
            parse_tree = parser.when_equation();

        } else if(!strcmp(entry_rule_name, "when_statement")){
            parse_tree = parser.when_statement();

        } else if(!strcmp(entry_rule_name, "connect_clause")){
            parse_tree = parser.connect_clause();

        } else if(!strcmp(entry_rule_name, "expression")){
            parse_tree = parser.expression();

        } else if(!strcmp(entry_rule_name, "simple_expression")){
            parse_tree = parser.simple_expression();

        } else if(!strcmp(entry_rule_name, "logical_expression")){
            parse_tree = parser.logical_expression();

        } else if(!strcmp(entry_rule_name, "logical_term")){
            parse_tree = parser.logical_term();

        } else if(!strcmp(entry_rule_name, "logical_factor")){
            parse_tree = parser.logical_factor();

        } else if(!strcmp(entry_rule_name, "relation")){
            parse_tree = parser.relation();

        } else if(!strcmp(entry_rule_name, "rel_op")){
            parse_tree = parser.rel_op();

        } else if(!strcmp(entry_rule_name, "arithmetic_expression")){
            parse_tree = parser.arithmetic_expression();

        } else if(!strcmp(entry_rule_name, "add_op")){
            parse_tree = parser.add_op();

        } else if(!strcmp(entry_rule_name, "term")){
            parse_tree = parser.term();

        } else if(!strcmp(entry_rule_name, "mul_op")){
            parse_tree = parser.mul_op();

        } else if(!strcmp(entry_rule_name, "factor")){
            parse_tree = parser.factor();

        } else if(!strcmp(entry_rule_name, "primary")){
            parse_tree = parser.primary();

        } else if(!strcmp(entry_rule_name, "name")){
            parse_tree = parser.name();

        } else if(!strcmp(entry_rule_name, "component_reference")){
            parse_tree = parser.component_reference();

        } else if(!strcmp(entry_rule_name, "function_call_args")){
            parse_tree = parser.function_call_args();

        } else if(!strcmp(entry_rule_name, "function_arguments")){
            parse_tree = parser.function_arguments();

        } else if(!strcmp(entry_rule_name, "named_arguments")){
            parse_tree = parser.named_arguments();

        } else if(!strcmp(entry_rule_name, "named_argument")){
            parse_tree = parser.named_argument();

        } else if(!strcmp(entry_rule_name, "function_argument")){
            parse_tree = parser.function_argument();

        } else if(!strcmp(entry_rule_name, "output_expression_list")){
            parse_tree = parser.output_expression_list();

        } else if(!strcmp(entry_rule_name, "expression_list")){
            parse_tree = parser.expression_list();

        } else if(!strcmp(entry_rule_name, "array_subscripts")){
            parse_tree = parser.array_subscripts();

        } else if(!strcmp(entry_rule_name, "subscript")){
            parse_tree = parser.subscript();

        } else if(!strcmp(entry_rule_name, "comment")){
            parse_tree = parser.comment();

        } else if(!strcmp(entry_rule_name, "string_comment")){
            parse_tree = parser.string_comment();

        } else if(!strcmp(entry_rule_name, "model_annotation")){
            parse_tree = parser.model_annotation();

        } else if(!strcmp(entry_rule_name, "annotation")){
            parse_tree = parser.annotation();

        } else {
            PyErr_SetString(PyExc_ValueError, "Invalid entry_rule_name");
            throw speedy_antlr::PythonException();
        }

        // Translate Parse tree to Python
        SA_modelicaTranslator visitor(&translator);
        result = visitor.visit(parse_tree);

        // Clean up data
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);

        return result;

    } catch(speedy_antlr::PythonException &e) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // Python exception already has error indicator set
        return NULL;
    } catch(...) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // An internal C++ exception was thrown.
        // Set error indicator to a generic runtime error
        PyErr_SetString(PyExc_RuntimeError, "Internal error");
        return NULL;
    }
}


extern "C" {

    static PyObject* c_do_parse(PyObject *self, PyObject *args) {
        return do_parse(self, args);
    }

    static PyMethodDef methods[] = {
        {
            "do_parse",  c_do_parse, METH_VARARGS,
            "Run parser"
        },
        {NULL, NULL, 0, NULL} /* Sentinel */
    };

    static struct PyModuleDef module = {
        PyModuleDef_HEAD_INIT,
        "sa_modelica_cpp_parser",   /* name of module */
        NULL, /* module documentation, may be NULL */
        -1,       /* size of per-interpreter state of the module,
                    or -1 if the module keeps state in global variables. */
        methods
    };
}


PyMODINIT_FUNC
PyInit_sa_modelica_cpp_parser(void) {
    PyObject *m = PyModule_Create(&module);
    return m;
}
